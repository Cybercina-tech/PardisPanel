from django.core.exceptions import ValidationError
from django.db import models
from django.utils.translation import gettext_lazy as _


class Template(models.Model):
    """Template model with JSONField for storing text field configurations."""
    
    name = models.CharField(
        max_length=100,
        unique=True,
        help_text="Unique name for this template"
    )
    category = models.ForeignKey(
        'category.Category',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        help_text="Category this template belongs to (optional)"
    )
    special_price_type = models.ForeignKey(
        'special_price.SpecialPriceType',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        help_text="Special price type this template belongs to (optional)"
    )
    image = models.ImageField(
        upload_to="templates/",
        help_text="Background image for the template"
    )
    config = models.JSONField(
        default=dict,
        blank=True,
        help_text="JSON configuration for text fields (auto-generated by editor)"
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "Template"
        verbose_name_plural = "Templates"
        ordering = ["-created_at"]

    def __str__(self) -> str:
        return self.name

    def clean(self):
        """Validate template name uniqueness and category/special_price exclusivity."""
        super().clean()
        if self.name:
            # Check for duplicate names excluding current instance
            qs = Template.objects.filter(name=self.name)
            if self.pk:
                qs = qs.exclude(pk=self.pk)
            if qs.exists():
                raise ValidationError({"name": _("A template with this name already exists.")})
        
        # Ensure category and special_price_type are mutually exclusive
        if self.category and self.special_price_type:
            raise ValidationError(
                _("Template cannot be assigned to both a category and a special price type. Please choose one.")
            )

    def save(self, *args, **kwargs):
        self.full_clean()
        return super().save(*args, **kwargs)

